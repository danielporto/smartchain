# Copyright (c) 2007-2013 Alysson Bessani, Eduardo Alchieri, Paulo Sousa, and the authors indicated in the @author tags
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

############################################
####### Communication Configurations #######
############################################

#HMAC algorithm used to authenticate messages between processes ('HmacSHA512' is the default value)
system.communication.hmacAlgorithm = HmacSHA512

#Algorithm to generate secret keys used to generate MACs ('PBKDF2WithHmacSHA1' is the default value)
system.communication.secretKeyAlgorithm = PBKDF2WithHmacSHA1

#Signature algorithm used to verify clients requests and to perform the authenticated Diffie-Hellman exchange during
#replica start-up ('SHA512withRSA' is the default value). This parameter is overriden in the event that a custom key loader is supplied
system.communication.signatureAlgorithm = SHA256withECDSA

# Algorithm used to compute hashes ('SHA-512' is the default value)
system.communication.hashAlgorithm = SHA-512

#HMAC algorithm provider ('SunJCE' is the default value)
system.communication.hmacAlgorithmProvider = SunJCE

#Secret keys algorith provider ('SunJCE' is the default value)
system.communication.secretKeyAlgorithmProvider = SunJCE

#Signature algorithm provider ('SunRsaSign' is the default value)
system.communication.signatureAlgorithmProvider = BC

#Hash algorithm provider ('SUN' is the default value)
system.communication.hashAlgorithmProvider = SUN

#Specify if the communication system should use a thread to send data (true or false)
system.communication.useSenderThread = true

#Force all processes to use the same public/private keys pair and secret key. This is useful when deploying experiments
#and benchmarks, but must not be used in production systems. This parameter will only work with the default key loader.
system.communication.defaultkeys = true

#IP address this replica should bind to. If this parameter does not have a valid ip address,
#the replica will fetch the host address on its own. If config/hosts.config specifies the
#loopback address for the host machine, this parameter is overriden by that
system.communication.bindaddress = auto

############################################
### Replication Algorithm Configurations ###
############################################

#Number of servers in the group 
system.servers.num = 4

#Maximum number of faulty replicas 
system.servers.f = 1

#Timeout to asking for a client request
system.totalordermulticast.timeout = 20000000


#Maximum batch size (in number of messages)
system.totalordermulticast.maxbatchsize = 400  

#Number of nonces (for non-determinism actions) generated
system.totalordermulticast.nonces = 10  

#if verification of leader-generated timestamps are increasing 
#it can only be used on systems in which the network clocks
#are synchronized 
system.totalordermulticast.verifyTimestamps = false

#Quantity of messages that can be stored in the receive queue of the communication system
system.communication.inQueueSize = 500000

# Quantity of messages that can be stored in the send queue of each replica
system.communication.outQueueSize = 500000

#Set to 1 if clients should use MAC vectors, set to 0 if otherwise
system.communication.useMACs = 1

#Set to 1 if clients should use digital signatures, set to 0 if otherwise
system.communication.useSignatures = 1

#Print information about the replica when it is shutdown
system.shutdownhook = true

#Size of the thread pool that transmits replies to clients. If set to 0, no thread pool is used and this
#done sequentially by the delivery thread instead.
system.numrepliers = 10

############################################
###### State Transfer Configurations #######
############################################

#Activate the state transfer protocol ('true' to activate, 'false' to de-activate)
system.totalordermulticast.state_transfer = true

#Maximum ahead-of-time message not discarded
system.totalordermulticast.highMark = 10000

#Maximum ahead-of-time message not discarded when the replica is still on EID 0 (after which the state transfer is triggered)
system.totalordermulticast.revival_highMark = 10

#Number of ahead-of-time messages necessary to trigger the state transfer after a request timeout occurs
system.totalordermulticast.timeout_highMark = 200

############################################
###### Log and Checkpoint Configurations ###
############################################

system.totalordermulticast.log = true
system.totalordermulticast.log_parallel = true
system.totalordermulticast.log_to_disk = false
system.totalordermulticast.sync_log = false

#Period at which BFT-SMaRt requests the state to the application (for the state transfer state protocol)
system.totalordermulticast.checkpoint_period = 100
system.totalordermulticast.global_checkpoint_period = 120

system.totalordermulticast.checkpoint_to_disk = false
system.totalordermulticast.sync_ckp = false

###### BLOCKCHAIN RELATED PARAMETERS #######

#Limit of batches per super-batch
system.totalordermulticast.log_batch_limit = 50

#Timeout for the super-batch in miliseconds
system.totalordermulticast.log_batch_timeout = 1000

#Batch logger type ('buffer', 'parallel', or 'async'). All types offer the same guarantees, albeit via different mechanisms:
#If type is buffer, data is only written to disk when its time to finalize the block and send the replies to clients
#If type is parallel, data is written to disk in parallel to execution, and the recoverables wait for the writes to finish when block is to be finalized and replies are to be sent
#If type is async, data is written to disk asynchronously, and the recoverables force all pending data to be stored when finalising the block and replying to clients
#If type is void, no data is written to disk. This is useful for benchmark purposes only
system.totalordermulticast.log_batch_type = async


############################################
###### Reconfiguration Configurations ######
############################################

#Replicas ID for the initial view, separated by a comma.
# The number of replicas in this parameter should be equal to that specified in 'system.servers.num'
system.initial.view = 0,1,2,3

#The ID of the trust third party (TTP)
system.ttp.id = 7002

#This sets if the system will function in Byzantine or crash-only mode. Set to "true" to support Byzantine faults
system.bft = true

system.numnettyworkers = 16

